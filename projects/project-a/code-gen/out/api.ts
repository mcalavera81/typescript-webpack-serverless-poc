/**
 * Customers API
 * Customers API is used to maintain customer information. This is used to create the propect customers, amend the customer information later on. This is also used to view list of customer as well as viewing all the details for a specific customer.
 *
 * OpenAPI spec version: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://localipv4/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* getCustomersErrorResponse
*/
export class GetCustomersErrorResponse {
    'header'?: QueryHeader;
    'body'?: GetCustomersErrorResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "QueryHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "GetCustomersErrorResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersErrorResponse.attributeTypeMap;
    }
}

export class GetCustomersErrorResponseBody {
    /**
    * This code refers the code of the error received
    */
    'code'?: string;
    /**
    * This description contains the whole explanation regarding to the code above
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersErrorResponseBody.attributeTypeMap;
    }
}

/**
* getCustomersRecordidErrorResponse
*/
export class GetCustomersRecordidErrorResponse {
    'header'?: ScreenHeader;
    'body'?: GetCustomersRecordidErrorResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "ScreenHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "GetCustomersRecordidErrorResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidErrorResponse.attributeTypeMap;
    }
}

export class GetCustomersRecordidErrorResponseBody {
    /**
    * This code refers the code of the error received
    */
    'code'?: string;
    /**
    * This description contains the whole explanation regarding to the code above
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidErrorResponseBody.attributeTypeMap;
    }
}

/**
* getCustomersRecordidResponse
*/
export class GetCustomersRecordidResponse {
    'header'?: ScreenHeader;
    'body'?: GetCustomersRecordidResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "ScreenHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "GetCustomersRecordidResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponse.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBody {
    /**
    * Vulnerability Type of Customer
    */
    'vulnerabilities'?: Array<GetCustomersRecordidResponseBodyVulnerabilities>;
    /**
    * This is the actual physical address of where the BIC code relates. Wherever possible the uploaded field is reformatted to show the following logical groups of information, in the following sequence (each logical group is delimited by ':') . Contact Person . Building, Floor,Apartment . Street Number, Street Name, Street Cardinal Point . Second Street Number,Second Street Name,Second Street Cardinal Point. 
    */
    'addresses'?: Array<GetCustomersRecordidResponseBodyAddresses>;
    /**
    * This is the contact details of the customer. 
    */
    'telephones'?: Array<GetCustomersRecordidResponseBodyTelephones>;
    /**
    * This is the email details of the customer.         
    */
    'emailDetails'?: Array<GetCustomersRecordidResponseBodyEmailDetails>;
    /**
    * Defines the document details
    */
    'legalDocuments'?: Array<GetCustomersRecordidResponseBodyLegalDocuments>;
    /**
    * Defines the customer relation details
    */
    'relationDetails'?: Array<GetCustomersRecordidResponseBodyRelationDetails>;
    /**
    * Defines the Tax details of a customer
    */
    'overseaTaxes'?: Array<GetCustomersRecordidResponseBodyOverseaTaxes>;
    /**
    * Details of Override messages generated
    */
    'overrideDetails'?: Array<GetCustomersRecordidResponseBodyOverrideDetails>;
    /**
    * First Surname of the customer
    */
    'firstSurname'?: string;
    /**
    * Second Surname of the customer
    */
    'secondSurname'?: string;
    /**
    * First name of the customer
    */
    'firstName'?: string;
    /**
    * Specifies an easy means of referencing Customer
    */
    'alias'?: string;
    /**
    * Customer's Gender
    */
    'genderTCode'?: string;
    /**
    * Marital Status of the Customer
    */
    'maritalStatusTCode'?: string;
    /**
    * Specifies how the cus is considered by the bank
    */
    'targetTCode'?: string;
    /**
    * Nationality of the Customer
    */
    'nationalityTCode'?: string;
    /**
    * Staff Code
    */
    'staffTCode'?: string;
    /**
    * Residence Code
    */
    'residenceTCode'?: string;
    /**
    * Specifies customer's date of birth. This additional client information is required by CRM. Standard date format (YYYY-MM-DD). Optional input.  No default value. 
    */
    'dateOfBirth'?: string;
    /**
    * Language Code
    */
    'languageTCode'?: string;
    /**
    * Industry Classification Code
    */
    'industryClasificationTCode'?: string;
    /**
    * Country Name of Customer Birth Place
    */
    'countryOfBirthTCode'?: string;
    /**
    * Province Name of Customer Birth Place
    */
    'provinceOfBirthTCode'?: string;
    /**
    * Birth City of Customer Birth Place
    */
    'cityOfBirth'?: string;
    /**
    * Occupation Classification Code
    */
    'occupationClasificationTCode'?: string;
    /**
    * Activity Type Code
    */
    'activityTypeTCode'?: string;
    /**
    * Education Level
    */
    'educationLevelTCode'?: string;
    /**
    * Merge Date
    */
    'mergeDate'?: string;
    /**
    * Record Status
    */
    'recordStatus'?: string;
    /**
    * Record Change Number
    */
    'currentNumber'?: number;
    /**
    * Record Inputter Name
    */
    'inputter'?: string;
    /**
    * Agent Name
    */
    'primaryAgentTcode'?: string;
    /**
    * Agent Group
    */
    'agentGroupTCode'?: string;
    /**
    * Vip Flag
    */
    'isVipTBoolean'?: string;
    /**
    * Type of Communication
    */
    'communicationTypeTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vulnerabilities",
            "baseName": "vulnerabilities",
            "type": "Array<GetCustomersRecordidResponseBodyVulnerabilities>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<GetCustomersRecordidResponseBodyAddresses>"
        },
        {
            "name": "telephones",
            "baseName": "telephones",
            "type": "Array<GetCustomersRecordidResponseBodyTelephones>"
        },
        {
            "name": "emailDetails",
            "baseName": "emailDetails",
            "type": "Array<GetCustomersRecordidResponseBodyEmailDetails>"
        },
        {
            "name": "legalDocuments",
            "baseName": "legalDocuments",
            "type": "Array<GetCustomersRecordidResponseBodyLegalDocuments>"
        },
        {
            "name": "relationDetails",
            "baseName": "relationDetails",
            "type": "Array<GetCustomersRecordidResponseBodyRelationDetails>"
        },
        {
            "name": "overseaTaxes",
            "baseName": "overseaTaxes",
            "type": "Array<GetCustomersRecordidResponseBodyOverseaTaxes>"
        },
        {
            "name": "overrideDetails",
            "baseName": "overrideDetails",
            "type": "Array<GetCustomersRecordidResponseBodyOverrideDetails>"
        },
        {
            "name": "firstSurname",
            "baseName": "firstSurname",
            "type": "string"
        },
        {
            "name": "secondSurname",
            "baseName": "secondSurname",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "genderTCode",
            "baseName": "genderTCode",
            "type": "string"
        },
        {
            "name": "maritalStatusTCode",
            "baseName": "maritalStatusTCode",
            "type": "string"
        },
        {
            "name": "targetTCode",
            "baseName": "targetTCode",
            "type": "string"
        },
        {
            "name": "nationalityTCode",
            "baseName": "nationalityTCode",
            "type": "string"
        },
        {
            "name": "staffTCode",
            "baseName": "staffTCode",
            "type": "string"
        },
        {
            "name": "residenceTCode",
            "baseName": "residenceTCode",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "languageTCode",
            "baseName": "languageTCode",
            "type": "string"
        },
        {
            "name": "industryClasificationTCode",
            "baseName": "industryClasificationTCode",
            "type": "string"
        },
        {
            "name": "countryOfBirthTCode",
            "baseName": "countryOfBirthTCode",
            "type": "string"
        },
        {
            "name": "provinceOfBirthTCode",
            "baseName": "provinceOfBirthTCode",
            "type": "string"
        },
        {
            "name": "cityOfBirth",
            "baseName": "cityOfBirth",
            "type": "string"
        },
        {
            "name": "occupationClasificationTCode",
            "baseName": "occupationClasificationTCode",
            "type": "string"
        },
        {
            "name": "activityTypeTCode",
            "baseName": "activityTypeTCode",
            "type": "string"
        },
        {
            "name": "educationLevelTCode",
            "baseName": "educationLevelTCode",
            "type": "string"
        },
        {
            "name": "mergeDate",
            "baseName": "mergeDate",
            "type": "string"
        },
        {
            "name": "recordStatus",
            "baseName": "recordStatus",
            "type": "string"
        },
        {
            "name": "currentNumber",
            "baseName": "currentNumber",
            "type": "number"
        },
        {
            "name": "inputter",
            "baseName": "inputter",
            "type": "string"
        },
        {
            "name": "primaryAgentTcode",
            "baseName": "primaryAgentTcode",
            "type": "string"
        },
        {
            "name": "agentGroupTCode",
            "baseName": "agentGroupTCode",
            "type": "string"
        },
        {
            "name": "isVipTBoolean",
            "baseName": "isVipTBoolean",
            "type": "string"
        },
        {
            "name": "communicationTypeTCode",
            "baseName": "communicationTypeTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBody.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyAddresses {
    /**
    * Street name of Customer's base address
    */
    'street'?: string;
    /**
    * Building number of Customer's base address
    */
    'number'?: string;
    /**
    * Flat number of Customer's base address
    */
    'floor'?: string;
    /**
    * Department name of Customer's base address
    */
    'department'?: string;
    /**
    * Building name of Customer's base address
    */
    'monoblock'?: string;
    /**
    * It is used to store neighbourhood name in case of an Argentinan address 
    */
    'additionalItems1'?: string;
    /**
    * It is used to store municipality name in case of an Argentinan address 
    */
    'additionalItems2'?: string;
    /**
    * 
    */
    'countryTCode'?: string;
    /**
    * 
    */
    'city'?: string;
    /**
    * 
    */
    'province'?: string;
    /**
    * Identifies the postal code for customer. On authorisation of a customer record corresponding postal code field in the DE.ADDRESS application will be updated. 1-35 type S (uppercase alpha or numeric) characters. (Optional input. No default value.) 
    */
    'postCode'?: string;
    /**
    * 
    */
    'addressTypeTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "floor",
            "baseName": "floor",
            "type": "string"
        },
        {
            "name": "department",
            "baseName": "department",
            "type": "string"
        },
        {
            "name": "monoblock",
            "baseName": "monoblock",
            "type": "string"
        },
        {
            "name": "additionalItems1",
            "baseName": "additionalItems1",
            "type": "string"
        },
        {
            "name": "additionalItems2",
            "baseName": "additionalItems2",
            "type": "string"
        },
        {
            "name": "countryTCode",
            "baseName": "countryTCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "postCode",
            "baseName": "postCode",
            "type": "string"
        },
        {
            "name": "addressTypeTCode",
            "baseName": "addressTypeTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyAddresses.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyEmailDetails {
    /**
    * Preferred Email Type
    */
    'preferredEmailTCode'?: string;
    /**
    * This field can contain e-mail addresses of the customer. This client contact data is required by CRM. On authorisation of a customer record corresponding email field in the DE.ADDRESS application will be updated with the first email address entered. Maximum of 50 characters allowedEmail address of the customer 
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "preferredEmailTCode",
            "baseName": "preferredEmailTCode",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyEmailDetails.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyLegalDocuments {
    /**
    * Legal Document identifier
    */
    'legalDocId'?: string;
    /**
    * Legal Document type
    */
    'legalDocTypeTCode'?: string;
    /**
    * Name as on Legal Document
    */
    'nameOnId'?: string;
    /**
    * Legal Document Issuing Authority
    */
    'issuingAuthority'?: string;
    /**
    * Defines the date of issue of document. Defaults to today if omitted. 8 numeric characters.  Mandatory input. 
    */
    'issueDate'?: string;
    /**
    * Defines the date of expiry of document.
    */
    'expirationDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "legalDocId",
            "baseName": "legalDocId",
            "type": "string"
        },
        {
            "name": "legalDocTypeTCode",
            "baseName": "legalDocTypeTCode",
            "type": "string"
        },
        {
            "name": "nameOnId",
            "baseName": "nameOnId",
            "type": "string"
        },
        {
            "name": "issuingAuthority",
            "baseName": "issuingAuthority",
            "type": "string"
        },
        {
            "name": "issueDate",
            "baseName": "issueDate",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyLegalDocuments.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyOverrideDetails {
    /**
    * Records the overrides generated during processing of an activity. All the overrides generated in the property class templates (AA.ARR.XXXX, where XXXX - Property Class) for the Activity input are updated in this field. Standard override field, Multi-valued. 
    */
    'override'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "override",
            "baseName": "override",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyOverrideDetails.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyOverseaTaxes {
    /**
    * Country of Tax for Customer
    */
    'taxCountryTCode'?: string;
    /**
    * Tin Number
    */
    'tin'?: string;
    /**
    * Tax Reason
    */
    'taxReasonTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taxCountryTCode",
            "baseName": "taxCountryTCode",
            "type": "string"
        },
        {
            "name": "tin",
            "baseName": "tin",
            "type": "string"
        },
        {
            "name": "taxReasonTCode",
            "baseName": "taxReasonTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyOverseaTaxes.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyRelationDetails {
    /**
    * 
    */
    'relationTCode'?: string;
    /**
    * Identifies the Customer to whom the Account belongs. This field maintains a link between the Customer and their Accounts. Internal Accounts are recognised by ID's which contain a Currency Code in the first 3 characters. These do not belong to Customers. 1-10 numeric character Customer Code or 3-10 type MNE (uppercase alpha or numeric or '.') character Customer Mnemonic. (Mandatory input for Customer Accounts not allowed for Internal Accounts). Can only be changed for Nostro accounts. A change is only allowed if the account is not specified in the EXT.ACCT.NO field of the AGENCY record for the old Customer number. Input here will be checked against the account number if an entry has been made in the customer code position on account parameter. This check is for account numbers that contain the customer code, the position within account number being specified by account parameter. Customer number can be changed only if the Account category 1000 to 9999 is specified in the field range ACCT.CATEG.STR and ACCT.CATEG.END of ACCOUNT.PARAMETER. This will allow change only if the account has joint holders and also allows the change only to a joint holder customer. Cannot change the customer if there are LIMITS attached to the account, if it is  single customer account without joint holders and if the account has been input as an AUTO.PAY.ACCOUNT or SUB ACCOUNT in another account with same main customer and currency. Will allow change to Nostro accounts even if the account category is specified in ACCOUNT.PARAMETER. 
    */
    'customerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "relationTCode",
            "baseName": "relationTCode",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyRelationDetails.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyTelephones {
    /**
    * Phone Prefix Code
    */
    'countryCodeTCode'?: string;
    /**
    * Phone Check
    */
    'isPrimaryTelephoneTBoolean'?: string;
    /**
    * Phone Number
    */
    'telephoneNumber'?: string;
    /**
    * Full Telephone Number
    */
    'fullTelephoneNumber'?: string;
    /**
    * Start Time
    */
    'startTime'?: string;
    /**
    * End Time
    */
    'endTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countryCodeTCode",
            "baseName": "countryCodeTCode",
            "type": "string"
        },
        {
            "name": "isPrimaryTelephoneTBoolean",
            "baseName": "isPrimaryTelephoneTBoolean",
            "type": "string"
        },
        {
            "name": "telephoneNumber",
            "baseName": "telephoneNumber",
            "type": "string"
        },
        {
            "name": "fullTelephoneNumber",
            "baseName": "fullTelephoneNumber",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyTelephones.attributeTypeMap;
    }
}

export class GetCustomersRecordidResponseBodyVulnerabilities {
    /**
    * Vulnerability Type of Customer
    */
    'vulnerabilityTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vulnerabilityTCode",
            "baseName": "vulnerabilityTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersRecordidResponseBodyVulnerabilities.attributeTypeMap;
    }
}

/**
* getCustomersResponse
*/
export class GetCustomersResponse {
    'header'?: QueryHeader;
    'body'?: GetCustomersResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "QueryHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "GetCustomersResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersResponse.attributeTypeMap;
    }
}

export class GetCustomersResponseBody extends Array<GetCustomersResponseBodyInner> {

    static discriminator: string | undefined = undefined;

}

export class GetCustomersResponseBodyInner {
    /**
    * Identifies the Customer to whom the Account belongs. This field maintains a link between the Customer and their Accounts. Internal Accounts are recognised by ID's which contain a Currency Code in the first 3 characters. These do not belong to Customers. 1-10 numeric character Customer Code or 3-10 type MNE (uppercase alpha or numeric or '.') character Customer Mnemonic. (Mandatory input for Customer Accounts not allowed for Internal Accounts). Can only be changed for Nostro accounts. A change is only allowed if the account is not specified in the EXT.ACCT.NO field of the AGENCY record for the old Customer number. Input here will be checked against the account number if an entry has been made in the customer code position on account parameter. This check is for account numbers that contain the customer code, the position within account number being specified by account parameter. Customer number can be changed only if the Account category 1000 to 9999 is specified in the field range ACCT.CATEG.STR and ACCT.CATEG.END of ACCOUNT.PARAMETER. This will allow change only if the account has joint holders and also allows the change only to a joint holder customer. Cannot change the customer if there are LIMITS attached to the account, if it is  single customer account without joint holders and if the account has been input as an AUTO.PAY.ACCOUNT or SUB ACCOUNT in another account with same main customer and currency. Will allow change to Nostro accounts even if the account category is specified in ACCOUNT.PARAMETER. 
    */
    'customerId'?: string;
    /**
    * First name of Customer
    */
    'firstName'?: string;
    /**
    * First Surname of Customer
    */
    'firstSurname'?: string;
    /**
    * Second Surname of Customer
    */
    'secondSurname'?: string;
    /**
    * Specifies customer's date of birth. This additional client information is required by CRM. Standard date format (YYYY-MM-DD). Optional input.  No default value. 
    */
    'dateOfBirth'?: string;
    /**
    * Defines the document details
    */
    'legalDocuments'?: Array<GetCustomersResponseBodyInnerLegalDocuments>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "firstSurname",
            "baseName": "firstSurname",
            "type": "string"
        },
        {
            "name": "secondSurname",
            "baseName": "secondSurname",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "legalDocuments",
            "baseName": "legalDocuments",
            "type": "Array<GetCustomersResponseBodyInnerLegalDocuments>"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersResponseBodyInner.attributeTypeMap;
    }
}

export class GetCustomersResponseBodyInnerLegalDocuments {
    /**
    * Legal Document Identifier Number
    */
    'legalDocId'?: string;
    /**
    * Legal Document Type
    */
    'legalDocTypeTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "legalDocId",
            "baseName": "legalDocId",
            "type": "string"
        },
        {
            "name": "legalDocTypeTCode",
            "baseName": "legalDocTypeTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCustomersResponseBodyInnerLegalDocuments.attributeTypeMap;
    }
}

/**
* payloadHeader
*/
export class PayloadHeader {
    /**
    * payloadHeader
    */
    'overrideAcceptId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "overrideAcceptId",
            "baseName": "override_acceptId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PayloadHeader.attributeTypeMap;
    }
}

export class PostCustomers {
    'header'?: PayloadHeader;
    'body'?: PostCustomersBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "PayloadHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "PostCustomersBody"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomers.attributeTypeMap;
    }
}

export class PostCustomersBody {
    /**
    * Group details
    */
    'groupsDetails'?: Array<PostCustomersBodyGroupsDetails>;
    /**
    * Vulnerability Type of Customer
    */
    'vulnerabilities'?: Array<GetCustomersRecordidResponseBodyVulnerabilities>;
    /**
    * This is the actual physical address of where the BIC code relates. Wherever possible the uploaded field is reformatted to show the following logical groups of information, in the following sequence (each logical group is delimited by ':') . Contact Person . Building, Floor,Apartment . Street Number, Street Name, Street Cardinal Point . Second Street Number,Second Street Name,Second Street Cardinal Point. 
    */
    'addresses'?: Array<GetCustomersRecordidResponseBodyAddresses>;
    /**
    * This is the contact details of the customer. 
    */
    'telephones'?: Array<PostCustomersRecordidUpdateBodyTelephones>;
    /**
    * This is the email details of the customer.         
    */
    'emailDetails'?: Array<GetCustomersRecordidResponseBodyEmailDetails>;
    /**
    * Defines the document details
    */
    'legalDocuments'?: Array<GetCustomersRecordidResponseBodyLegalDocuments>;
    /**
    * Defines the customer relation details
    */
    'relationDetails'?: Array<GetCustomersRecordidResponseBodyRelationDetails>;
    /**
    * Defines the Tax details of a customer
    */
    'overseaTaxes'?: Array<GetCustomersRecordidResponseBodyOverseaTaxes>;
    /**
    * First Surname of the customer
    */
    'firstSurname'?: string;
    /**
    * Second Surname of the customer
    */
    'secondSurname'?: string;
    /**
    * First name of the customer
    */
    'firstName'?: string;
    /**
    * Specifies an easy means of referencing Customer
    */
    'alias'?: string;
    /**
    * Customer's Gender
    */
    'genderTCode'?: string;
    /**
    * Marital Status of the Customer
    */
    'maritalStatusTCode'?: string;
    /**
    * Specifies how the cus is considered by the bank
    */
    'targetTCode'?: string;
    /**
    * Nationality of the Customer
    */
    'nationalityTCode'?: string;
    /**
    * Staff Code
    */
    'staffTCode'?: string;
    /**
    * Residence Code
    */
    'residenceTCode'?: string;
    /**
    * Specifies customer's date of birth. This additional client information is required by CRM. Standard date format (YYYY-MM-DD). Optional input.  No default value. 
    */
    'dateOfBirth'?: string;
    /**
    * Language Code
    */
    'languageTCode'?: string;
    /**
    * Industry Classification Code
    */
    'industryClasificationTCode'?: string;
    /**
    * Country Name of Customer Birth Place
    */
    'countryOfBirthTCode'?: string;
    /**
    * Province Name of Customer Birth Place
    */
    'provinceOfBirthTCode'?: string;
    /**
    * Birth City of Customer Birth Place
    */
    'cityOfBirth'?: string;
    /**
    * Occupation Classification Code
    */
    'occupationClasificationTCode'?: string;
    /**
    * Activity Type Code
    */
    'activityTypeTCode'?: string;
    /**
    * Education Level
    */
    'educationLevelTCode'?: string;
    /**
    * Agent Name
    */
    'primaryAgentTCode'?: string;
    /**
    * Agent Group
    */
    'agentGroupTCode'?: string;
    /**
    * Vip Flag
    */
    'isVipTBoolean'?: string;
    /**
    * Type of Communication
    */
    'communicationTypeTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupsDetails",
            "baseName": "groupsDetails",
            "type": "Array<PostCustomersBodyGroupsDetails>"
        },
        {
            "name": "vulnerabilities",
            "baseName": "vulnerabilities",
            "type": "Array<GetCustomersRecordidResponseBodyVulnerabilities>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<GetCustomersRecordidResponseBodyAddresses>"
        },
        {
            "name": "telephones",
            "baseName": "telephones",
            "type": "Array<PostCustomersRecordidUpdateBodyTelephones>"
        },
        {
            "name": "emailDetails",
            "baseName": "emailDetails",
            "type": "Array<GetCustomersRecordidResponseBodyEmailDetails>"
        },
        {
            "name": "legalDocuments",
            "baseName": "legalDocuments",
            "type": "Array<GetCustomersRecordidResponseBodyLegalDocuments>"
        },
        {
            "name": "relationDetails",
            "baseName": "relationDetails",
            "type": "Array<GetCustomersRecordidResponseBodyRelationDetails>"
        },
        {
            "name": "overseaTaxes",
            "baseName": "overseaTaxes",
            "type": "Array<GetCustomersRecordidResponseBodyOverseaTaxes>"
        },
        {
            "name": "firstSurname",
            "baseName": "firstSurname",
            "type": "string"
        },
        {
            "name": "secondSurname",
            "baseName": "secondSurname",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "genderTCode",
            "baseName": "genderTCode",
            "type": "string"
        },
        {
            "name": "maritalStatusTCode",
            "baseName": "maritalStatusTCode",
            "type": "string"
        },
        {
            "name": "targetTCode",
            "baseName": "targetTCode",
            "type": "string"
        },
        {
            "name": "nationalityTCode",
            "baseName": "nationalityTCode",
            "type": "string"
        },
        {
            "name": "staffTCode",
            "baseName": "staffTCode",
            "type": "string"
        },
        {
            "name": "residenceTCode",
            "baseName": "residenceTCode",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "languageTCode",
            "baseName": "languageTCode",
            "type": "string"
        },
        {
            "name": "industryClasificationTCode",
            "baseName": "industryClasificationTCode",
            "type": "string"
        },
        {
            "name": "countryOfBirthTCode",
            "baseName": "countryOfBirthTCode",
            "type": "string"
        },
        {
            "name": "provinceOfBirthTCode",
            "baseName": "provinceOfBirthTCode",
            "type": "string"
        },
        {
            "name": "cityOfBirth",
            "baseName": "cityOfBirth",
            "type": "string"
        },
        {
            "name": "occupationClasificationTCode",
            "baseName": "occupationClasificationTCode",
            "type": "string"
        },
        {
            "name": "activityTypeTCode",
            "baseName": "activityTypeTCode",
            "type": "string"
        },
        {
            "name": "educationLevelTCode",
            "baseName": "educationLevelTCode",
            "type": "string"
        },
        {
            "name": "primaryAgentTCode",
            "baseName": "primaryAgentTCode",
            "type": "string"
        },
        {
            "name": "agentGroupTCode",
            "baseName": "agentGroupTCode",
            "type": "string"
        },
        {
            "name": "isVipTBoolean",
            "baseName": "isVipTBoolean",
            "type": "string"
        },
        {
            "name": "communicationTypeTCode",
            "baseName": "communicationTypeTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersBody.attributeTypeMap;
    }
}

export class PostCustomersBodyGroupsDetails {
    /**
    * 
    */
    'groupsTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupsTCode",
            "baseName": "groupsTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersBodyGroupsDetails.attributeTypeMap;
    }
}

/**
* postCustomersErrorResponse
*/
export class PostCustomersErrorResponse {
    'header'?: ScreenHeader;
    'body'?: PostCustomersErrorResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "ScreenHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "PostCustomersErrorResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersErrorResponse.attributeTypeMap;
    }
}

export class PostCustomersErrorResponseBody {
    /**
    * This code refers the code of the error received
    */
    'code'?: string;
    /**
    * This description contains the whole explanation regarding to the code above
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersErrorResponseBody.attributeTypeMap;
    }
}

/**
* postCustomersRecordidUpdate
*/
export class PostCustomersRecordidUpdate {
    'header'?: PayloadHeader;
    'body'?: PostCustomersRecordidUpdateBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "PayloadHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "PostCustomersRecordidUpdateBody"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdate.attributeTypeMap;
    }
}

export class PostCustomersRecordidUpdateBody {
    /**
    * Vulnerability Type of Customer
    */
    'vulnerabilities'?: Array<GetCustomersRecordidResponseBodyVulnerabilities>;
    /**
    * This is the actual physical address of where the BIC code relates. Wherever possible the uploaded field is reformatted to show the following logical groups of information, in the following sequence (each logical group is delimited by ':') . Contact Person . Building, Floor,Apartment . Street Number, Street Name, Street Cardinal Point . Second Street Number,Second Street Name,Second Street Cardinal Point. 
    */
    'addresses'?: Array<GetCustomersRecordidResponseBodyAddresses>;
    /**
    * This is the contact details of the customer. 
    */
    'telephones'?: Array<PostCustomersRecordidUpdateBodyTelephones>;
    /**
    * This is the email details of the customer.         
    */
    'emailDetails'?: Array<GetCustomersRecordidResponseBodyEmailDetails>;
    /**
    * Defines the document details
    */
    'legalDocuments'?: Array<PostCustomersRecordidUpdateBodyLegalDocuments>;
    /**
    * Defines the customer relation details
    */
    'relationDetails'?: Array<GetCustomersRecordidResponseBodyRelationDetails>;
    /**
    * Defines the Tax details of a customer
    */
    'overseaTaxes'?: Array<GetCustomersRecordidResponseBodyOverseaTaxes>;
    /**
    * First Surname of the customer
    */
    'firstSurname'?: string;
    /**
    * Second Surname of the customer
    */
    'secondSurname'?: string;
    /**
    * First name of the customer
    */
    'firstName'?: string;
    /**
    * Specifies an easy means of referencing Customer
    */
    'alias'?: string;
    /**
    * Customer's Gender
    */
    'genderTCode'?: string;
    /**
    * Marital Status of the Customer
    */
    'maritalStatusTCode'?: string;
    /**
    * Specifies how the cus is considered by the bank
    */
    'targetTCode'?: string;
    /**
    * Nationality of the Customer
    */
    'nationalityTCode'?: string;
    /**
    * Staff Code
    */
    'staffTCode'?: string;
    /**
    * Residence Code
    */
    'residenceTCode'?: string;
    /**
    * Specifies customer's date of birth. This additional client information is required by CRM. Standard date format (YYYY-MM-DD). Optional input.  No default value. 
    */
    'dateOfBirth'?: string;
    /**
    * Language Code
    */
    'languageTCode'?: string;
    /**
    * Industry Classification Code
    */
    'industryClasificationTCode'?: string;
    /**
    * Country Name of Customer Birth Place
    */
    'countryOfBirthTCode'?: string;
    /**
    * Province Name of Customer Birth Place
    */
    'provinceOfBirthTCode'?: string;
    /**
    * Birth City of Customer Birth Place
    */
    'cityOfBirth'?: string;
    /**
    * Occupation Classification Code
    */
    'occupationClasificationTCode'?: string;
    /**
    * Activity Type Code
    */
    'activityTypeTCode'?: string;
    /**
    * Education Level
    */
    'educationLevelTCode'?: string;
    /**
    * Agent Name
    */
    'primaryAgentTCode'?: string;
    /**
    * Agent Group
    */
    'agentGroupTCode'?: string;
    /**
    * Vip Flag
    */
    'isVipTBoolean'?: string;
    /**
    * Type of Communication
    */
    'communicationTypeTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vulnerabilities",
            "baseName": "vulnerabilities",
            "type": "Array<GetCustomersRecordidResponseBodyVulnerabilities>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<GetCustomersRecordidResponseBodyAddresses>"
        },
        {
            "name": "telephones",
            "baseName": "telephones",
            "type": "Array<PostCustomersRecordidUpdateBodyTelephones>"
        },
        {
            "name": "emailDetails",
            "baseName": "emailDetails",
            "type": "Array<GetCustomersRecordidResponseBodyEmailDetails>"
        },
        {
            "name": "legalDocuments",
            "baseName": "legalDocuments",
            "type": "Array<PostCustomersRecordidUpdateBodyLegalDocuments>"
        },
        {
            "name": "relationDetails",
            "baseName": "relationDetails",
            "type": "Array<GetCustomersRecordidResponseBodyRelationDetails>"
        },
        {
            "name": "overseaTaxes",
            "baseName": "overseaTaxes",
            "type": "Array<GetCustomersRecordidResponseBodyOverseaTaxes>"
        },
        {
            "name": "firstSurname",
            "baseName": "firstSurname",
            "type": "string"
        },
        {
            "name": "secondSurname",
            "baseName": "secondSurname",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "genderTCode",
            "baseName": "genderTCode",
            "type": "string"
        },
        {
            "name": "maritalStatusTCode",
            "baseName": "maritalStatusTCode",
            "type": "string"
        },
        {
            "name": "targetTCode",
            "baseName": "targetTCode",
            "type": "string"
        },
        {
            "name": "nationalityTCode",
            "baseName": "nationalityTCode",
            "type": "string"
        },
        {
            "name": "staffTCode",
            "baseName": "staffTCode",
            "type": "string"
        },
        {
            "name": "residenceTCode",
            "baseName": "residenceTCode",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "languageTCode",
            "baseName": "languageTCode",
            "type": "string"
        },
        {
            "name": "industryClasificationTCode",
            "baseName": "industryClasificationTCode",
            "type": "string"
        },
        {
            "name": "countryOfBirthTCode",
            "baseName": "countryOfBirthTCode",
            "type": "string"
        },
        {
            "name": "provinceOfBirthTCode",
            "baseName": "provinceOfBirthTCode",
            "type": "string"
        },
        {
            "name": "cityOfBirth",
            "baseName": "cityOfBirth",
            "type": "string"
        },
        {
            "name": "occupationClasificationTCode",
            "baseName": "occupationClasificationTCode",
            "type": "string"
        },
        {
            "name": "activityTypeTCode",
            "baseName": "activityTypeTCode",
            "type": "string"
        },
        {
            "name": "educationLevelTCode",
            "baseName": "educationLevelTCode",
            "type": "string"
        },
        {
            "name": "primaryAgentTCode",
            "baseName": "primaryAgentTCode",
            "type": "string"
        },
        {
            "name": "agentGroupTCode",
            "baseName": "agentGroupTCode",
            "type": "string"
        },
        {
            "name": "isVipTBoolean",
            "baseName": "isVipTBoolean",
            "type": "string"
        },
        {
            "name": "communicationTypeTCode",
            "baseName": "communicationTypeTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdateBody.attributeTypeMap;
    }
}

export class PostCustomersRecordidUpdateBodyLegalDocuments {
    /**
    * Legal Document identifier
    */
    'legalDocIdlegalDocId'?: string;
    /**
    * Legal Document type
    */
    'legalDocTypeTCode'?: string;
    /**
    * Name as on Legal Document
    */
    'nameOnId'?: string;
    /**
    * Legal Document Issuing Authority
    */
    'issuingAuthority'?: string;
    /**
    * Defines the date of issue of document. Defaults to today if omitted. 8 numeric characters.  Mandatory input. 
    */
    'issueDate'?: string;
    /**
    * Defines the date of expiry of document.
    */
    'expirationDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "legalDocIdlegalDocId",
            "baseName": "legalDocIdlegalDocId",
            "type": "string"
        },
        {
            "name": "legalDocTypeTCode",
            "baseName": "legalDocTypeTCode",
            "type": "string"
        },
        {
            "name": "nameOnId",
            "baseName": "nameOnId",
            "type": "string"
        },
        {
            "name": "issuingAuthority",
            "baseName": "issuingAuthority",
            "type": "string"
        },
        {
            "name": "issueDate",
            "baseName": "issueDate",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdateBodyLegalDocuments.attributeTypeMap;
    }
}

export class PostCustomersRecordidUpdateBodyTelephones {
    /**
    * Phone Prefix Code
    */
    'countryCodeTCode'?: string;
    /**
    * Phone Check
    */
    'isPrimaryTelephoneTBoolean'?: string;
    /**
    * Phone Number
    */
    'telephoneNumber'?: string;
    /**
    * Start Time
    */
    'startTime'?: string;
    /**
    * End Time
    */
    'endTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countryCodeTCode",
            "baseName": "countryCodeTCode",
            "type": "string"
        },
        {
            "name": "isPrimaryTelephoneTBoolean",
            "baseName": "isPrimaryTelephoneTBoolean",
            "type": "string"
        },
        {
            "name": "telephoneNumber",
            "baseName": "telephoneNumber",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdateBodyTelephones.attributeTypeMap;
    }
}

/**
* postCustomersRecordidUpdateErrorResponse
*/
export class PostCustomersRecordidUpdateErrorResponse {
    'header'?: ScreenHeader;
    'body'?: PostCustomersRecordidUpdateErrorResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "ScreenHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "PostCustomersRecordidUpdateErrorResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdateErrorResponse.attributeTypeMap;
    }
}

/**
* Record doesn't exists
*/
export class PostCustomersRecordidUpdateErrorResponseBody {
    /**
    * This code refers the code of the error received
    */
    'code'?: string;
    /**
    * This description contains the whole explanation regarding to the code above
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdateErrorResponseBody.attributeTypeMap;
    }
}

/**
* postCustomersRecordidUpdateResponse
*/
export class PostCustomersRecordidUpdateResponse {
    'header'?: ScreenHeader;
    'body'?: PostCustomersRecordidUpdateResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "ScreenHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "PostCustomersRecordidUpdateResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdateResponse.attributeTypeMap;
    }
}

export class PostCustomersRecordidUpdateResponseBody {
    /**
    * Vulnerability Type of Customer
    */
    'vulnerabilities'?: Array<GetCustomersRecordidResponseBodyVulnerabilities>;
    /**
    * This is the actual physical address of where the BIC code relates. Wherever possible the uploaded field is reformatted to show the following logical groups of information, in the following sequence (each logical group is delimited by ':') . Contact Person . Building, Floor,Apartment . Street Number, Street Name, Street Cardinal Point . Second Street Number,Second Street Name,Second Street Cardinal Point. 
    */
    'addresses'?: Array<GetCustomersRecordidResponseBodyAddresses>;
    /**
    * This is the contact details of the customer. 
    */
    'telephones'?: Array<GetCustomersRecordidResponseBodyTelephones>;
    /**
    * This is the email details of the customer.         
    */
    'emailDetails'?: Array<GetCustomersRecordidResponseBodyEmailDetails>;
    /**
    * Defines the document details
    */
    'legalDocuments'?: Array<GetCustomersRecordidResponseBodyLegalDocuments>;
    /**
    * Defines the customer relation details
    */
    'relationDetails'?: Array<GetCustomersRecordidResponseBodyRelationDetails>;
    /**
    * Defines the Tax details of a customer
    */
    'overseaTaxes'?: Array<GetCustomersRecordidResponseBodyOverseaTaxes>;
    /**
    * Details of Override messages generated
    */
    'overrideDetails'?: Array<GetCustomersRecordidResponseBodyOverrideDetails>;
    /**
    * First Surname of the customer
    */
    'firstSurname'?: string;
    /**
    * Second Surname of the customer
    */
    'secondSurname'?: string;
    /**
    * First name of the customer
    */
    'firstName'?: string;
    /**
    * Specifies an easy means of referencing Customer
    */
    'alias'?: string;
    /**
    * Customer's Gender
    */
    'genderTCode'?: string;
    /**
    * Marital Status of the Customer
    */
    'maritalStatusTCode'?: string;
    /**
    * Specifies how the cus is considered by the bank
    */
    'targetTCode'?: string;
    /**
    * Nationality of the Customer
    */
    'nationalityTCode'?: string;
    /**
    * Staff Code
    */
    'staffTCode'?: string;
    /**
    * Residence Code
    */
    'residenceTCode'?: string;
    /**
    * Specifies customer's date of birth. This additional client information is required by CRM. Standard date format (YYYY-MM-DD). Optional input.  No default value. 
    */
    'dateOfBirth'?: string;
    /**
    * Language Code
    */
    'languageTCode'?: string;
    /**
    * Industry Classification Code
    */
    'industryClasificationTCode'?: string;
    /**
    * Country Name of Customer Birth Place
    */
    'countryOfBirthTCode'?: string;
    /**
    * Province Name of Customer Birth Place
    */
    'provinceOfBirthTCode'?: string;
    /**
    * Birth City of Customer Birth Place
    */
    'cityOfBirth'?: string;
    /**
    * Occupation Classification Code
    */
    'occupationClasificationTCode'?: string;
    /**
    * Activity Type Code
    */
    'activityTypeTCode'?: string;
    /**
    * Education Level
    */
    'educationLevelTCode'?: string;
    /**
    * Merge Date
    */
    'mergeDate'?: string;
    /**
    * Record Status
    */
    'recordStatus'?: string;
    /**
    * Record Change Number
    */
    'currentNumber'?: number;
    /**
    * Record Inputter Name
    */
    'inputter'?: string;
    /**
    * Agent Name
    */
    'primaryAgentTCode'?: string;
    /**
    * Agent Group
    */
    'agentGroupTCode'?: string;
    /**
    * Vip Flag
    */
    'isVipTBoolean'?: string;
    /**
    * Type of Communication
    */
    'communicationTypeTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vulnerabilities",
            "baseName": "vulnerabilities",
            "type": "Array<GetCustomersRecordidResponseBodyVulnerabilities>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<GetCustomersRecordidResponseBodyAddresses>"
        },
        {
            "name": "telephones",
            "baseName": "telephones",
            "type": "Array<GetCustomersRecordidResponseBodyTelephones>"
        },
        {
            "name": "emailDetails",
            "baseName": "emailDetails",
            "type": "Array<GetCustomersRecordidResponseBodyEmailDetails>"
        },
        {
            "name": "legalDocuments",
            "baseName": "legalDocuments",
            "type": "Array<GetCustomersRecordidResponseBodyLegalDocuments>"
        },
        {
            "name": "relationDetails",
            "baseName": "relationDetails",
            "type": "Array<GetCustomersRecordidResponseBodyRelationDetails>"
        },
        {
            "name": "overseaTaxes",
            "baseName": "overseaTaxes",
            "type": "Array<GetCustomersRecordidResponseBodyOverseaTaxes>"
        },
        {
            "name": "overrideDetails",
            "baseName": "overrideDetails",
            "type": "Array<GetCustomersRecordidResponseBodyOverrideDetails>"
        },
        {
            "name": "firstSurname",
            "baseName": "firstSurname",
            "type": "string"
        },
        {
            "name": "secondSurname",
            "baseName": "secondSurname",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "genderTCode",
            "baseName": "genderTCode",
            "type": "string"
        },
        {
            "name": "maritalStatusTCode",
            "baseName": "maritalStatusTCode",
            "type": "string"
        },
        {
            "name": "targetTCode",
            "baseName": "targetTCode",
            "type": "string"
        },
        {
            "name": "nationalityTCode",
            "baseName": "nationalityTCode",
            "type": "string"
        },
        {
            "name": "staffTCode",
            "baseName": "staffTCode",
            "type": "string"
        },
        {
            "name": "residenceTCode",
            "baseName": "residenceTCode",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "languageTCode",
            "baseName": "languageTCode",
            "type": "string"
        },
        {
            "name": "industryClasificationTCode",
            "baseName": "industryClasificationTCode",
            "type": "string"
        },
        {
            "name": "countryOfBirthTCode",
            "baseName": "countryOfBirthTCode",
            "type": "string"
        },
        {
            "name": "provinceOfBirthTCode",
            "baseName": "provinceOfBirthTCode",
            "type": "string"
        },
        {
            "name": "cityOfBirth",
            "baseName": "cityOfBirth",
            "type": "string"
        },
        {
            "name": "occupationClasificationTCode",
            "baseName": "occupationClasificationTCode",
            "type": "string"
        },
        {
            "name": "activityTypeTCode",
            "baseName": "activityTypeTCode",
            "type": "string"
        },
        {
            "name": "educationLevelTCode",
            "baseName": "educationLevelTCode",
            "type": "string"
        },
        {
            "name": "mergeDate",
            "baseName": "mergeDate",
            "type": "string"
        },
        {
            "name": "recordStatus",
            "baseName": "recordStatus",
            "type": "string"
        },
        {
            "name": "currentNumber",
            "baseName": "currentNumber",
            "type": "number"
        },
        {
            "name": "inputter",
            "baseName": "inputter",
            "type": "string"
        },
        {
            "name": "primaryAgentTCode",
            "baseName": "primaryAgentTCode",
            "type": "string"
        },
        {
            "name": "agentGroupTCode",
            "baseName": "agentGroupTCode",
            "type": "string"
        },
        {
            "name": "isVipTBoolean",
            "baseName": "isVipTBoolean",
            "type": "string"
        },
        {
            "name": "communicationTypeTCode",
            "baseName": "communicationTypeTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersRecordidUpdateResponseBody.attributeTypeMap;
    }
}

/**
* PostCustomersResponse
*/
export class PostCustomersResponse {
    'header'?: ScreenHeader;
    'body'?: PostCustomersResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "ScreenHeader"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "PostCustomersResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersResponse.attributeTypeMap;
    }
}

export class PostCustomersResponseBody {
    'groupsDetails'?: Array<PostCustomersBodyGroupsDetails>;
    /**
    * Vulnerability Type of Customer
    */
    'vulnerabilities'?: Array<GetCustomersRecordidResponseBodyVulnerabilities>;
    /**
    * This is the actual physical address of where the BIC code relates. Wherever possible the uploaded field is reformatted to show the following logical groups of information, in the following sequence (each logical group is delimited by ':') . Contact Person . Building, Floor,Apartment . Street Number, Street Name, Street Cardinal Point . Second Street Number,Second Street Name,Second Street Cardinal Point. 
    */
    'addresses'?: Array<GetCustomersRecordidResponseBodyAddresses>;
    /**
    * This is the contact details of the customer. 
    */
    'telephones'?: Array<GetCustomersRecordidResponseBodyTelephones>;
    /**
    * This is the email details of the customer.         
    */
    'emailDetails'?: Array<GetCustomersRecordidResponseBodyEmailDetails>;
    /**
    * Defines the document details
    */
    'legalDocuments'?: Array<GetCustomersRecordidResponseBodyLegalDocuments>;
    /**
    * Defines the customer relation details
    */
    'relationDetails'?: Array<GetCustomersRecordidResponseBodyRelationDetails>;
    /**
    * Defines the Tax details of a customer
    */
    'overseaTaxes'?: Array<GetCustomersRecordidResponseBodyOverseaTaxes>;
    /**
    * Details of Override messages generated
    */
    'overrideDetails'?: Array<GetCustomersRecordidResponseBodyOverrideDetails>;
    /**
    * First Surname of the customer
    */
    'firstSurname'?: string;
    /**
    * Second Surname of the customer
    */
    'secondSurname'?: string;
    /**
    * First name of the customer
    */
    'firstName'?: string;
    /**
    * Specifies an easy means of referencing Customer
    */
    'alias'?: string;
    /**
    * Customer's Gender
    */
    'genderTCode'?: string;
    /**
    * Marital Status of the Customer
    */
    'maritalStatusTCode'?: string;
    /**
    * Specifies how the cus is considered by the bank
    */
    'targetTCode'?: string;
    /**
    * Nationality of the Customer
    */
    'nationalityTCode'?: string;
    /**
    * Staff Code
    */
    'staffTCode'?: string;
    /**
    * Residence Code
    */
    'residenceTCode'?: string;
    /**
    * Specifies customer's date of birth. This additional client information is required by CRM. Standard date format (YYYY-MM-DD). Optional input.  No default value. 
    */
    'dateOfBirth'?: string;
    /**
    * Language Code
    */
    'languageTCode'?: string;
    /**
    * Industry Classification Code
    */
    'industryClasificationTCode'?: string;
    /**
    * Country Name of Customer Birth Place
    */
    'countryOfBirthTCode'?: string;
    /**
    * Province Name of Customer Birth Place
    */
    'provinceOfBirthTCode'?: string;
    /**
    * Birth City of Customer Birth Place
    */
    'cityOfBirth'?: string;
    /**
    * Occupation Classification Code
    */
    'occupationClasificationTCode'?: string;
    /**
    * Activity Type Code
    */
    'activityTypeTCode'?: string;
    /**
    * Education Level
    */
    'educationLevelTCode'?: string;
    /**
    * Merge Date
    */
    'mergeDate'?: string;
    /**
    * Record Status
    */
    'recordStatus'?: string;
    /**
    * Record Change Number
    */
    'currentNumber'?: number;
    /**
    * Record Inputter Name
    */
    'inputter'?: string;
    /**
    * Agent Name
    */
    'primaryAgentTCode'?: string;
    /**
    * Agent Group
    */
    'agentGroupTCode'?: string;
    /**
    * Vip Flag
    */
    'isVipTBoolean'?: string;
    /**
    * Type of Communication
    */
    'communicationTypeTCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupsDetails",
            "baseName": "groupsDetails",
            "type": "Array<PostCustomersBodyGroupsDetails>"
        },
        {
            "name": "vulnerabilities",
            "baseName": "vulnerabilities",
            "type": "Array<GetCustomersRecordidResponseBodyVulnerabilities>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<GetCustomersRecordidResponseBodyAddresses>"
        },
        {
            "name": "telephones",
            "baseName": "telephones",
            "type": "Array<GetCustomersRecordidResponseBodyTelephones>"
        },
        {
            "name": "emailDetails",
            "baseName": "emailDetails",
            "type": "Array<GetCustomersRecordidResponseBodyEmailDetails>"
        },
        {
            "name": "legalDocuments",
            "baseName": "legalDocuments",
            "type": "Array<GetCustomersRecordidResponseBodyLegalDocuments>"
        },
        {
            "name": "relationDetails",
            "baseName": "relationDetails",
            "type": "Array<GetCustomersRecordidResponseBodyRelationDetails>"
        },
        {
            "name": "overseaTaxes",
            "baseName": "overseaTaxes",
            "type": "Array<GetCustomersRecordidResponseBodyOverseaTaxes>"
        },
        {
            "name": "overrideDetails",
            "baseName": "overrideDetails",
            "type": "Array<GetCustomersRecordidResponseBodyOverrideDetails>"
        },
        {
            "name": "firstSurname",
            "baseName": "firstSurname",
            "type": "string"
        },
        {
            "name": "secondSurname",
            "baseName": "secondSurname",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "genderTCode",
            "baseName": "genderTCode",
            "type": "string"
        },
        {
            "name": "maritalStatusTCode",
            "baseName": "maritalStatusTCode",
            "type": "string"
        },
        {
            "name": "targetTCode",
            "baseName": "targetTCode",
            "type": "string"
        },
        {
            "name": "nationalityTCode",
            "baseName": "nationalityTCode",
            "type": "string"
        },
        {
            "name": "staffTCode",
            "baseName": "staffTCode",
            "type": "string"
        },
        {
            "name": "residenceTCode",
            "baseName": "residenceTCode",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "languageTCode",
            "baseName": "languageTCode",
            "type": "string"
        },
        {
            "name": "industryClasificationTCode",
            "baseName": "industryClasificationTCode",
            "type": "string"
        },
        {
            "name": "countryOfBirthTCode",
            "baseName": "countryOfBirthTCode",
            "type": "string"
        },
        {
            "name": "provinceOfBirthTCode",
            "baseName": "provinceOfBirthTCode",
            "type": "string"
        },
        {
            "name": "cityOfBirth",
            "baseName": "cityOfBirth",
            "type": "string"
        },
        {
            "name": "occupationClasificationTCode",
            "baseName": "occupationClasificationTCode",
            "type": "string"
        },
        {
            "name": "activityTypeTCode",
            "baseName": "activityTypeTCode",
            "type": "string"
        },
        {
            "name": "educationLevelTCode",
            "baseName": "educationLevelTCode",
            "type": "string"
        },
        {
            "name": "mergeDate",
            "baseName": "mergeDate",
            "type": "string"
        },
        {
            "name": "recordStatus",
            "baseName": "recordStatus",
            "type": "string"
        },
        {
            "name": "currentNumber",
            "baseName": "currentNumber",
            "type": "number"
        },
        {
            "name": "inputter",
            "baseName": "inputter",
            "type": "string"
        },
        {
            "name": "primaryAgentTCode",
            "baseName": "primaryAgentTCode",
            "type": "string"
        },
        {
            "name": "agentGroupTCode",
            "baseName": "agentGroupTCode",
            "type": "string"
        },
        {
            "name": "isVipTBoolean",
            "baseName": "isVipTBoolean",
            "type": "string"
        },
        {
            "name": "communicationTypeTCode",
            "baseName": "communicationTypeTCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomersResponseBody.attributeTypeMap;
    }
}

/**
* Header for query
*/
export class QueryHeader {
    'audit'?: ScreenHeaderAudit;
    'pageSize'?: number;
    'pageStart'?: number;
    'totalSize'?: number;
    'pageToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "audit",
            "baseName": "audit",
            "type": "ScreenHeaderAudit"
        },
        {
            "name": "pageSize",
            "baseName": "page_size",
            "type": "number"
        },
        {
            "name": "pageStart",
            "baseName": "page_start",
            "type": "number"
        },
        {
            "name": "totalSize",
            "baseName": "total_size",
            "type": "number"
        },
        {
            "name": "pageToken",
            "baseName": "page_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return QueryHeader.attributeTypeMap;
    }
}

/**
* Header of the screen
*/
export class ScreenHeader {
    'id'?: string;
    'status'?: string;
    'transactionStatus'?: string;
    'audit'?: ScreenHeaderAudit;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "transactionStatus",
            "baseName": "transactionStatus",
            "type": "string"
        },
        {
            "name": "audit",
            "baseName": "audit",
            "type": "ScreenHeaderAudit"
        }    ];

    static getAttributeTypeMap() {
        return ScreenHeader.attributeTypeMap;
    }
}

export class ScreenHeaderAudit {
    't24Time'?: number;
    'parseTime'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "t24Time",
            "baseName": "T24_time",
            "type": "number"
        },
        {
            "name": "parseTime",
            "baseName": "parse_time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ScreenHeaderAudit.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "GetCustomersErrorResponse": GetCustomersErrorResponse,
    "GetCustomersErrorResponseBody": GetCustomersErrorResponseBody,
    "GetCustomersRecordidErrorResponse": GetCustomersRecordidErrorResponse,
    "GetCustomersRecordidErrorResponseBody": GetCustomersRecordidErrorResponseBody,
    "GetCustomersRecordidResponse": GetCustomersRecordidResponse,
    "GetCustomersRecordidResponseBody": GetCustomersRecordidResponseBody,
    "GetCustomersRecordidResponseBodyAddresses": GetCustomersRecordidResponseBodyAddresses,
    "GetCustomersRecordidResponseBodyEmailDetails": GetCustomersRecordidResponseBodyEmailDetails,
    "GetCustomersRecordidResponseBodyLegalDocuments": GetCustomersRecordidResponseBodyLegalDocuments,
    "GetCustomersRecordidResponseBodyOverrideDetails": GetCustomersRecordidResponseBodyOverrideDetails,
    "GetCustomersRecordidResponseBodyOverseaTaxes": GetCustomersRecordidResponseBodyOverseaTaxes,
    "GetCustomersRecordidResponseBodyRelationDetails": GetCustomersRecordidResponseBodyRelationDetails,
    "GetCustomersRecordidResponseBodyTelephones": GetCustomersRecordidResponseBodyTelephones,
    "GetCustomersRecordidResponseBodyVulnerabilities": GetCustomersRecordidResponseBodyVulnerabilities,
    "GetCustomersResponse": GetCustomersResponse,
    "GetCustomersResponseBody": GetCustomersResponseBody,
    "GetCustomersResponseBodyInner": GetCustomersResponseBodyInner,
    "GetCustomersResponseBodyInnerLegalDocuments": GetCustomersResponseBodyInnerLegalDocuments,
    "PayloadHeader": PayloadHeader,
    "PostCustomers": PostCustomers,
    "PostCustomersBody": PostCustomersBody,
    "PostCustomersBodyGroupsDetails": PostCustomersBodyGroupsDetails,
    "PostCustomersErrorResponse": PostCustomersErrorResponse,
    "PostCustomersErrorResponseBody": PostCustomersErrorResponseBody,
    "PostCustomersRecordidUpdate": PostCustomersRecordidUpdate,
    "PostCustomersRecordidUpdateBody": PostCustomersRecordidUpdateBody,
    "PostCustomersRecordidUpdateBodyLegalDocuments": PostCustomersRecordidUpdateBodyLegalDocuments,
    "PostCustomersRecordidUpdateBodyTelephones": PostCustomersRecordidUpdateBodyTelephones,
    "PostCustomersRecordidUpdateErrorResponse": PostCustomersRecordidUpdateErrorResponse,
    "PostCustomersRecordidUpdateErrorResponseBody": PostCustomersRecordidUpdateErrorResponseBody,
    "PostCustomersRecordidUpdateResponse": PostCustomersRecordidUpdateResponse,
    "PostCustomersRecordidUpdateResponseBody": PostCustomersRecordidUpdateResponseBody,
    "PostCustomersResponse": PostCustomersResponse,
    "PostCustomersResponseBody": PostCustomersResponseBody,
    "QueryHeader": QueryHeader,
    "ScreenHeader": ScreenHeader,
    "ScreenHeaderAudit": ScreenHeaderAudit,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum CreateCustomerApiApiKeys {
}

export class CreateCustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CreateCustomerApiApiKeys, value: string) {
        (this.authentications as any)[CreateCustomerApiApiKeys[key]].apiKey = value;
    }
    /**
     * API to input customer detail in the record.
     * @summary API to create customer record
     * @param accessToken login token
     * @param payload 
     * @param progressId Progress Identifier
     * @param {*} [options] Override http request options.
     */
    public postCustomers (accessToken: string, payload: PostCustomers, progressId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomersResponse;  }> {
        const localVarPath = this.basePath + '/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling postCustomers.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling postCustomers.');
        }

        localVarHeaderParams['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        localVarHeaderParams['progressId'] = ObjectSerializer.serialize(progressId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "PostCustomers")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeleteCustomerApiApiKeys {
}

export class DeleteCustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeleteCustomerApiApiKeys, value: string) {
        (this.authentications as any)[DeleteCustomerApiApiKeys[key]].apiKey = value;
    }
    /**
     * API to delete customer. It is used to delete the prospect customer
     * @summary API to delete customer
     * @param accessToken login token
     * @param recordid Customer Number
     * @param progressId Progress Identifier
     * @param {*} [options] Override http request options.
     */
    public deleteCustomer (accessToken: string, recordid: string, progressId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCustomersRecordidResponse;  }> {
        const localVarPath = this.basePath + '/customers/{recordid}/delete'
            .replace('{' + 'recordid' + '}', encodeURIComponent(String(recordid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling deleteCustomer.');
        }

        // verify required parameter 'recordid' is not null or undefined
        if (recordid === null || recordid === undefined) {
            throw new Error('Required parameter recordid was null or undefined when calling deleteCustomer.');
        }

        localVarHeaderParams['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        localVarHeaderParams['progressId'] = ObjectSerializer.serialize(progressId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCustomersRecordidResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCustomersRecordidResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GetCustomerDetailsApiApiKeys {
}

export class GetCustomerDetailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GetCustomerDetailsApiApiKeys, value: string) {
        (this.authentications as any)[GetCustomerDetailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * API to get particular customer detail. It is acheived by supplying the customer Id as path parameter
     * @summary API to get customer detail
     * @param accessToken login token
     * @param recordid Customer Number
     * @param progressId Progress Identifier
     * @param {*} [options] Override http request options.
     */
    public getCustomersRecordid (accessToken: string, recordid: string, progressId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCustomersRecordidResponse;  }> {
        const localVarPath = this.basePath + '/customers/{recordid}'
            .replace('{' + 'recordid' + '}', encodeURIComponent(String(recordid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling getCustomersRecordid.');
        }

        // verify required parameter 'recordid' is not null or undefined
        if (recordid === null || recordid === undefined) {
            throw new Error('Required parameter recordid was null or undefined when calling getCustomersRecordid.');
        }

        localVarHeaderParams['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        localVarHeaderParams['progressId'] = ObjectSerializer.serialize(progressId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCustomersRecordidResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCustomersRecordidResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ListCustomerSearchApiApiKeys {
}

export class ListCustomerSearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ListCustomerSearchApiApiKeys, value: string) {
        (this.authentications as any)[ListCustomerSearchApiApiKeys[key]].apiKey = value;
    }
    /**
     * API to get information about all customers
     * @summary API to get list of customer alongwith their details
     * @param accessToken login token
     * @param progressId Progress Identifier
     * @param firstName First Name of the Customer
     * @param firstSurname First Surname of the customer
     * @param secondSurname Second Surname of the Customer
     * @param dateOfBirth Customers Date of Birth
     * @param legalDocId Legal Document Id Number
     * @param legalDocTypeTCode Type of Legal Document
     * @param pageSize The total number of records per page
     * @param pageStart The record from which the response should be displayed
     * @param pageToken Random and unique string for each page. Used for security purpose
     * @param {*} [options] Override http request options.
     */
    public getCustomers (accessToken: string, progressId?: string, firstName?: string, firstSurname?: string, secondSurname?: string, dateOfBirth?: string, legalDocId?: string, legalDocTypeTCode?: string, pageSize?: number, pageStart?: number, pageToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCustomersResponse;  }> {
        const localVarPath = this.basePath + '/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling getCustomers.');
        }

        if (firstName !== undefined) {
            localVarQueryParameters['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (firstSurname !== undefined) {
            localVarQueryParameters['firstSurname'] = ObjectSerializer.serialize(firstSurname, "string");
        }

        if (secondSurname !== undefined) {
            localVarQueryParameters['secondSurname'] = ObjectSerializer.serialize(secondSurname, "string");
        }

        if (dateOfBirth !== undefined) {
            localVarQueryParameters['dateOfBirth'] = ObjectSerializer.serialize(dateOfBirth, "string");
        }

        if (legalDocId !== undefined) {
            localVarQueryParameters['legalDocId'] = ObjectSerializer.serialize(legalDocId, "string");
        }

        if (legalDocTypeTCode !== undefined) {
            localVarQueryParameters['legalDocTypeTCode'] = ObjectSerializer.serialize(legalDocTypeTCode, "string");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['page_size'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (pageStart !== undefined) {
            localVarQueryParameters['page_start'] = ObjectSerializer.serialize(pageStart, "number");
        }

        if (pageToken !== undefined) {
            localVarQueryParameters['page_token'] = ObjectSerializer.serialize(pageToken, "string");
        }

        localVarHeaderParams['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        localVarHeaderParams['progressId'] = ObjectSerializer.serialize(progressId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UpdateCustomerApiApiKeys {
}

export class UpdateCustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UpdateCustomerApiApiKeys, value: string) {
        (this.authentications as any)[UpdateCustomerApiApiKeys[key]].apiKey = value;
    }
    /**
     * API to update particular customer details. Modification/changes will be done for customer whose Id is supplied as path parameter.
     * @summary API to update customer information
     * @param accessToken login token
     * @param recordid Customer Number
     * @param payload 
     * @param progressId Progress Identifier
     * @param {*} [options] Override http request options.
     */
    public postCustomersRecordidUpdate (accessToken: string, recordid: string, payload: PostCustomersRecordidUpdate, progressId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomersRecordidUpdateResponse;  }> {
        const localVarPath = this.basePath + '/customers/{recordid}/update'
            .replace('{' + 'recordid' + '}', encodeURIComponent(String(recordid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling postCustomersRecordidUpdate.');
        }

        // verify required parameter 'recordid' is not null or undefined
        if (recordid === null || recordid === undefined) {
            throw new Error('Required parameter recordid was null or undefined when calling postCustomersRecordidUpdate.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling postCustomersRecordidUpdate.');
        }

        localVarHeaderParams['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        localVarHeaderParams['progressId'] = ObjectSerializer.serialize(progressId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "PostCustomersRecordidUpdate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomersRecordidUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomersRecordidUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
